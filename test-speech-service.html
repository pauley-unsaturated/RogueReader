<!DOCTYPE html>
<html>
<head>
    <title>Speech Service Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 50px auto;
            padding: 20px;
            background: #1a1a1a;
            color: #fff;
        }
        .container {
            background: #2a2a2a;
            padding: 30px;
            border-radius: 10px;
        }
        h1 { color: #00ff00; }
        button {
            padding: 15px 25px;
            margin: 10px;
            font-size: 18px;
            background: #00ff00;
            color: #000;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        button:hover { background: #00dd00; }
        button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        #status {
            margin: 20px 0;
            padding: 15px;
            background: #333;
            border-radius: 5px;
            min-height: 200px;
            font-family: monospace;
            white-space: pre-wrap;
        }
        .test-word {
            font-size: 24px;
            font-weight: bold;
            color: #ffff00;
            margin: 20px 0;
            text-align: center;
            padding: 15px;
            background: #444;
            border-radius: 5px;
        }
        .error { color: #ff6666; }
        .success { color: #00ff00; }
        .warning { color: #ffaa00; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üé§ Direct Speech Service Test</h1>

        <div class="test-word" id="testWord">Ready to test...</div>

        <div>
            <button id="testBtn">Test Speech Recognition</button>
            <button id="stopBtn" disabled>Stop Recording</button>
        </div>

        <div id="status"></div>
    </div>

    <script type="module">
        // Simplified speech recognition service for testing
        class TestSpeechService {
            constructor() {
                this.apiKey = prompt('Enter your OpenAI API key:');
                this.isRecording = false;
                this.mediaRecorder = null;
                this.audioChunks = [];
                this.currentStream = null;
            }

            async startRecording(options) {
                log('üé§ Starting recording test...');
                try {
                    // Get microphone stream
                    this.currentStream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            channelCount: 1,
                            sampleRate: 16000,
                            echoCancellation: true,
                            noiseSuppression: true,
                            autoGainControl: true
                        }
                    });

                    log('‚úÖ Microphone stream acquired');

                    const audioTrack = this.currentStream.getAudioTracks()[0];
                    log(`üìç Using: ${audioTrack.label}`);

                    // Test codec selection
                    const mimeTypes = [
                        'audio/webm;codecs=opus',
                        'audio/ogg;codecs=opus',
                        'audio/mp4;codecs=mp4a.40.2',
                        'audio/mp4',
                        'audio/webm',
                        'audio/wav',
                        'audio/mpeg'
                    ];

                    let selectedMimeType = '';
                    for (let i = 0; i < mimeTypes.length; i++) {
                        if (MediaRecorder.isTypeSupported(mimeTypes[i])) {
                            selectedMimeType = mimeTypes[i];
                            log(`‚úÖ Selected format #${i + 1}: ${selectedMimeType}`);
                            break;
                        }
                    }

                    if (!selectedMimeType) {
                        throw new Error('No supported audio format found');
                    }

                    // Create MediaRecorder
                    this.audioChunks = [];
                    this.mediaRecorder = new MediaRecorder(this.currentStream, {
                        mimeType: selectedMimeType
                    });

                    return new Promise((resolve) => {
                        const timeoutId = setTimeout(() => {
                            log('‚è∞ Recording timeout reached');
                            this.stopRecording();
                            resolve({
                                text: '',
                                confidence: 0,
                                isCriticalHit: false,
                                isTimeout: true,
                                isError: false
                            });
                        }, options.timeoutMs);

                        this.mediaRecorder.ondataavailable = (event) => {
                            log(`üìä Data chunk: ${event.data.size} bytes`);
                            if (event.data.size > 0) {
                                this.audioChunks.push(event.data);
                            }
                        };

                        this.mediaRecorder.onstart = () => {
                            log('üî¥ Recording started');

                            // Safari safety check
                            setTimeout(() => {
                                if (this.audioChunks.length === 0) {
                                    log('‚ö†Ô∏è No data after 2 seconds, requesting data...');
                                    if (this.mediaRecorder && this.mediaRecorder.state === 'recording') {
                                        this.mediaRecorder.requestData();
                                    }
                                }
                            }, 2000);
                        };

                        this.mediaRecorder.onstop = async () => {
                            log('‚èπÔ∏è Recording stopped');
                            clearTimeout(timeoutId);

                            if (this.audioChunks.length === 0) {
                                log('‚ùå No audio data captured', true);
                                resolve({
                                    text: '',
                                    confidence: 0,
                                    isCriticalHit: false,
                                    isTimeout: false,
                                    isError: true,
                                    errorMessage: 'No audio data captured'
                                });
                                return;
                            }

                            try {
                                const audioBlob = new Blob(this.audioChunks, { type: selectedMimeType });
                                log(`‚úÖ Audio blob created: ${audioBlob.size} bytes`);

                                // Test transcription
                                const result = await this.transcribeAudio(audioBlob, options.targetWord);
                                resolve(result);
                            } catch (error) {
                                log(`‚ùå Transcription failed: ${error.message}`, true);
                                resolve({
                                    text: '',
                                    confidence: 0,
                                    isCriticalHit: false,
                                    isTimeout: false,
                                    isError: true,
                                    errorMessage: error.message
                                });
                            }
                        };

                        this.isRecording = true;

                        // Safari-specific start
                        const userAgent = navigator.userAgent;
                        if (userAgent.includes('Safari') && !userAgent.includes('Chrome')) {
                            log('üì± Safari detected: using 100ms timeslice');
                            this.mediaRecorder.start(100);
                        } else {
                            log('üñ•Ô∏è Standard browser: using 1000ms timeslice');
                            this.mediaRecorder.start(1000);
                        }
                    });

                } catch (error) {
                    log(`‚ùå Failed to start recording: ${error.message}`, true);
                    return {
                        text: '',
                        confidence: 0,
                        isCriticalHit: false,
                        isTimeout: false,
                        isError: true,
                        errorMessage: error.message
                    };
                }
            }

            stopRecording() {
                log('üõë Stop recording requested');
                if (this.mediaRecorder && this.isRecording) {
                    this.isRecording = false;
                    this.mediaRecorder.stop();

                    if (this.currentStream) {
                        this.currentStream.getTracks().forEach(track => track.stop());
                        this.currentStream = null;
                    }
                }
            }

            async transcribeAudio(audioBlob, targetWord) {
                log('üîÑ Starting Whisper transcription...');
                log(`üìä Blob: ${audioBlob.size} bytes, type: ${audioBlob.type}`);

                if (!this.apiKey) {
                    throw new Error('No API key provided');
                }

                const formData = new FormData();
                formData.append('file', audioBlob, 'audio.' + (audioBlob.type.includes('mp4') ? 'mp4' : 'webm'));
                formData.append('model', 'whisper-1');
                formData.append('language', 'en');
                formData.append('response_format', 'verbose_json');
                formData.append('prompt', `The user should say the word: ${targetWord}`);

                const response = await fetch('https://api.openai.com/v1/audio/transcriptions', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${this.apiKey}`
                    },
                    body: formData
                });

                log(`üì° API Response: ${response.status} ${response.statusText}`);

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`API request failed: ${response.status} - ${errorText}`);
                }

                const data = await response.json();
                log('üéØ Whisper result:', false);
                console.log(data);

                const transcribedText = data.text?.toLowerCase().trim() || '';
                const targetLower = targetWord.toLowerCase().trim();

                log(`üìù Transcribed: "${transcribedText}"`);
                log(`üéØ Target: "${targetLower}"`);

                // Simple accuracy calculation
                const accuracy = transcribedText === targetLower ? 1.0 : 0.7;
                const isCriticalHit = accuracy >= 0.95;

                return {
                    text: transcribedText,
                    confidence: data.confidence || accuracy,
                    pronunciation_score: accuracy,
                    isCriticalHit,
                    isTimeout: false,
                    isError: false
                };
            }
        }

        // UI Logic
        const statusEl = document.getElementById('status');
        const testBtn = document.getElementById('testBtn');
        const stopBtn = document.getElementById('stopBtn');
        const testWordEl = document.getElementById('testWord');

        let speechService = null;

        function log(message, isError = false) {
            const timestamp = new Date().toLocaleTimeString();
            const className = isError ? 'error' : 'success';
            statusEl.innerHTML += `<span class="${className}">${timestamp} - ${message}</span>\n`;
            statusEl.scrollTop = statusEl.scrollHeight;
            console.log(message);
        }

        async function runTest() {
            try {
                if (!speechService) {
                    speechService = new TestSpeechService();
                }

                const testWords = ['cat', 'dog', 'house', 'tree', 'book'];
                const testWord = testWords[Math.floor(Math.random() * testWords.length)];

                testWordEl.textContent = `Say: "${testWord}"`;

                testBtn.disabled = true;
                stopBtn.disabled = false;

                log(`üéØ Testing with word: "${testWord}"`);

                const result = await speechService.startRecording({
                    targetWord: testWord,
                    timeoutMs: 8000,
                    language: 'en-US'
                });

                log('üèÅ Test completed');
                console.log('Final result:', result);

                if (result.isError) {
                    log(`‚ùå Error: ${result.errorMessage}`, true);
                } else if (result.isTimeout) {
                    log('‚è∞ Timeout occurred', true);
                } else {
                    log(`‚úÖ Success! Heard: "${result.text}"`);
                    log(`üìä Confidence: ${(result.confidence * 100).toFixed(1)}%`);
                    if (result.isCriticalHit) {
                        log('üí• CRITICAL HIT!');
                    }
                }

            } catch (error) {
                log(`‚ùå Test failed: ${error.message}`, true);
            } finally {
                testBtn.disabled = false;
                stopBtn.disabled = true;
                testWordEl.textContent = 'Test completed';
            }
        }

        function stopTest() {
            if (speechService) {
                speechService.stopRecording();
            }
        }

        testBtn.addEventListener('click', runTest);
        stopBtn.addEventListener('click', stopTest);

        // Initial setup
        log('‚ÑπÔ∏è Direct Speech Service Test Ready');
        log('üìã This bypasses the game and tests speech recognition directly');
        log('üéØ Click "Test Speech Recognition" to begin');
    </script>
</body>
</html>